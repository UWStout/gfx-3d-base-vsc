// Import bootstrap's contents for webpack (not used below)
// These lines simply ensure that bootstrap is placed in the bundle files
// that are generated by webpack so we don't have to link them separately
import 'bootstrap'
import 'bootstrap/dist/css/bootstrap.min.css'

// Import jQuery as the usual '$' variable
import $ from 'jquery'

// Import the three.js library
import * as THREE from 'three'

// Import our special three.js cube that randomly rotates
import RandoCube from './objects/RandoCube'

// To run once after the DOM is fully loaded
$(document).ready(() => {
  // Initialize the three.js scene
  initThree()

  // Setup resize callback for the window
  $(window).resize(checkResize)

  // Start the animation
  requestAnimationFrame(animate)
})

// Variables used below
let renderer, scene, camera
let widgetWidth, widgetHeight, resizeNeeded

// Initialize three.js geometry, scene, and renderer
function initThree () {
  // Build the scene with a bunch of randomly rotating cubes
  scene = new THREE.Scene()
  for (let y = 0; y < 3; y++) {
    for (let x = 0; x < 5; x++) {
      let cube = new RandoCube(0.2)
      cube.position.x = (x - 2) * 0.4
      cube.position.y = (y - 1) * 0.4
      scene.add(cube)
    }
  }

  // Make a renderer that will draw the scene
  renderer = new THREE.WebGLRenderer({ antialias: true })
  $('#GLWidget').append(renderer.domElement)
  widgetWidth = $('#GLWidget').width()
  widgetHeight = $('#GLWidget').height()

  // Make a perspective projection camera for the scene
  let aspect = widgetWidth / widgetHeight
  camera = new THREE.PerspectiveCamera(35, aspect, 0.01, 10)
  camera.position.z = 3

  // Call resize once so everything is syncronized
  resize()
}

// Compare widget dimensions and flag if they've changed
function checkResize () {
  if ($('#GLWidget').width() !== widgetWidth ||
      $('#GLWidget').height() !== widgetHeight) {
    resizeNeeded = true
  }
}

// Syncronize the widget dimensions with the three.js renderer
function resize () {
  let container = $('#GLWidget')
  camera.aspect = container.width() / container.height()
  camera.updateProjectionMatrix()
  renderer.setSize(container.width(), container.height())

  widgetWidth = $('#GLWidget').width()
  widgetHeight = $('#GLWidget').height()
}

// Render and animate the scene
function animate () {
  // Queue the next animation frame (continuously animates)
  requestAnimationFrame(animate)

  // Do a resize if it is needed
  if (resizeNeeded) {
    resizeNeeded = false
    resize()
  }

  // Update each cube so it rotates
  scene.children.forEach((box) => {
    box.update()
  })

  // Render the scene
  renderer.render(scene, camera)
}
